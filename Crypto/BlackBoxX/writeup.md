
# 解説

まず、ファイル **"blackbox"** を**file** コマンドで調べるとELFであることがわかるので、実行してみます。

すると、**"PlainText:"** と出てきて、入力を求められるので、適当に入力してみます。

すると、**"Code:〇〇〇"** と出てくるので、どうやら入力した文を暗号化するプログラムであることがわかります。

出力されたのは0~9,a~fの文字列であったので、これは16進数の整数またはそれを結合したものと推測できます。

最初にした**file'** コマンドでは **"stripped"** と出てきていました。また、ファイルサイズも大きく、

静的リンクコンパイルされたものだと推測できます。

なのでGhidraでのデコンパイルによる解析は最短解法とは言い難いでしょう。

まず、アルゴリズムの特徴を探っていきます。
 
**"a"** を何回か入力してみます。すると、いずれも **"265868"** と出力されます。

だから、決定的アルゴリズムであると推測できます。

**"b"** と入力してみます。すると **"323134"** と出力されます。

**"ab"** と入力してみます。すると **"265868423286"** と返されます。

**"abc"** と入力してみます。すると **"265868423286dca945"** と返されます。

**暗号文＝Enc(平文)** と表すことにします。

まず、いずれも暗号文の文字数は平文の文字数の６倍です。

また、

**Enc("ab")=Enc("a")+〇**

**Enc("abc")=Enc("ab")+〇**

です。

これらのことから以下のことが推測できます。

1. 一文字を6桁の16進数に変換している。

1. ある文字の暗号化には、それ以降の文字は影響しない。

1. 平文で、位置が違うならば文字が同じでも違う暗号化がなされる。

**"bbc"** と入力すると、 **"3231344232e8dca945"** が返されます。

**Enc("abc")** と **Enc("bbc")** の３文字目つまりcに相当する部分は等しいです。

また、２文字目は同じbであるにも関わらず対応する部分が異なっています。

よって、以下のことが推測できます。

「ある文字の暗号化には、一つ前の文字は影響するがそれ以前は影響しない。」

わかったことをまとめると、これは

「各文字の自身の値・位置・一つ前の文字の値を用いてそれぞれ独立に6桁16進数に変換し、結合して出力するアルゴリズム」

であることが推測できます。一見これは３変数関数のように思えますが、

文字の位置は一意に決定されます。また、前の文字の値も一意に与えられます。

よって、実質的には１変数関数と考えてよいです。

なので、復号の計算量は、n文字の平文とすると、(文字の種類数)×n,**O(n)** で、線形時間で解けるであろうことがわかります。


c言語で復号します(僕は)。

実装方針としては、

1. 平文の配列を用意

1. 引数として現在の位置とASCIIコードを与えられ、system()で"blackbox"を起動し与えられた位置まで暗号化して出力が暗号文と合致するか返す関数を用意。

1. for文で回して平文の配列をどんどん決めていく。

よって、```FLAG：pakenCTF{Y0u_1i8hte6_7he_dArKNe55}```が得られました。
